//! Solana-Zcash Privacy Bridge
//! 
//! Enables cross-chain privacy transfers between Solana and Zcash
//! using stealth addresses, partial notes, and MPC verification
//!
//! ## Deployment Instructions
//! 
//! 1. Build the program: `anchor build`
//! 2. Get the program ID: `anchor keys list`
//! 3. Update the declare_id! below with the actual program ID
//! 4. Rebuild and deploy: `anchor build && anchor deploy`
//! 5. Set VITE_ZCASH_BRIDGE_PROGRAM_ID in your .env file

use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Mint, Transfer};
use anchor_spl::associated_token::AssociatedToken;

// IMPORTANT: This program ID is auto-generated by Anchor on first build.
// After running `anchor build`, get the actual program ID with `anchor keys list`
// and update this value, then rebuild before deploying.
declare_id!("6zEeAV8FZqqDHJ1fnoeYKgok9XNkCaGi77ES3xG8k3qa");

#[program]
pub mod zcash_bridge {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        config: BridgeConfig,
    ) -> Result<()> {
        let bridge = &mut ctx.accounts.bridge_state;
        bridge.authority = ctx.accounts.authority.key();
        bridge.operator = config.operator;
        bridge.wrapped_zec_mint = ctx.accounts.wrapped_zec_mint.key();
        bridge.vault = ctx.accounts.vault.key();
        bridge.deposit_nonce = 0;
        bridge.withdrawal_nonce = 0;
        bridge.total_deposited = 0;
        bridge.total_withdrawn = 0;
        bridge.is_paused = false;
        bridge.min_deposit = config.min_deposit;
        bridge.max_deposit = config.max_deposit;
        bridge.protocol_fee_bps = config.protocol_fee_bps;
        bridge.bump = ctx.bumps.bridge_state;
        
        emit!(BridgeInitialized {
            authority: bridge.authority,
            operator: bridge.operator,
            wrapped_zec_mint: bridge.wrapped_zec_mint,
            timestamp: Clock::get()?.unix_timestamp,
        });
        
        Ok(())
    }

    pub fn register_stealth_meta_address(
        ctx: Context<RegisterStealthMetaAddress>,
        spend_pub_key: [u8; 33],
        viewing_pub_key: [u8; 33],
    ) -> Result<()> {
        let meta_address = &mut ctx.accounts.meta_address;
        meta_address.owner = ctx.accounts.user.key();
        meta_address.spend_pub_key = spend_pub_key;
        meta_address.viewing_pub_key = viewing_pub_key;
        meta_address.is_active = true;
        meta_address.created_at = Clock::get()?.unix_timestamp;
        meta_address.bump = ctx.bumps.meta_address;
        
        emit!(MetaAddressRegistered {
            owner: meta_address.owner,
            spend_pub_key,
            viewing_pub_key,
            timestamp: meta_address.created_at,
        });
        
        Ok(())
    }

    pub fn initiate_deposit(
        ctx: Context<InitiateDeposit>,
        amount: u64,
        zcash_shielded_address: [u8; 78],
        memo: [u8; 64],
    ) -> Result<()> {
        let bridge = &ctx.accounts.bridge_state;
        
        require!(!bridge.is_paused, BridgeError::BridgePaused);
        require!(amount >= bridge.min_deposit, BridgeError::DepositTooSmall);
        require!(amount <= bridge.max_deposit, BridgeError::DepositTooLarge);
        
        let fee = (amount as u128)
            .checked_mul(bridge.protocol_fee_bps as u128)
            .unwrap()
            .checked_div(10000)
            .unwrap() as u64;
        let net_amount = amount.checked_sub(fee).unwrap();
        
        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.user_token_account.to_account_info(),
                    to: ctx.accounts.vault.to_account_info(),
                    authority: ctx.accounts.user.to_account_info(),
                },
            ),
            amount,
        )?;
        
        let deposit = &mut ctx.accounts.deposit_ticket;
        let bridge_mut = &mut ctx.accounts.bridge_state;
        
        deposit.ticket_id = bridge_mut.deposit_nonce;
        deposit.depositor = ctx.accounts.user.key();
        deposit.amount = net_amount;
        deposit.fee = fee;
        deposit.zcash_shielded_address = zcash_shielded_address;
        deposit.memo = memo;
        deposit.status = DepositStatus::Pending;
        deposit.created_at = Clock::get()?.unix_timestamp;
        deposit.processed_at = 0;
        deposit.zcash_tx_id = [0u8; 32];
        deposit.bump = ctx.bumps.deposit_ticket;
        
        bridge_mut.deposit_nonce = bridge_mut.deposit_nonce.checked_add(1).unwrap();
        bridge_mut.total_deposited = bridge_mut.total_deposited.checked_add(net_amount).unwrap();
        
        emit!(DepositInitiated {
            ticket_id: deposit.ticket_id,
            depositor: deposit.depositor,
            amount: deposit.amount,
            zcash_address_hash: hash_zcash_address(&zcash_shielded_address),
            timestamp: deposit.created_at,
        });
        
        Ok(())
    }

    pub fn confirm_deposit(
        ctx: Context<ConfirmDeposit>,
        zcash_tx_id: [u8; 32],
        proof: DepositProof,
    ) -> Result<()> {
        let deposit = &mut ctx.accounts.deposit_ticket;
        
        require!(deposit.status == DepositStatus::Pending, BridgeError::InvalidDepositStatus);
        require!(ctx.accounts.operator.key() == ctx.accounts.bridge_state.operator, BridgeError::Unauthorized);
        
        require!(verify_deposit_proof(&proof, deposit), BridgeError::InvalidProof);
        
        deposit.status = DepositStatus::Confirmed;
        deposit.processed_at = Clock::get()?.unix_timestamp;
        deposit.zcash_tx_id = zcash_tx_id;
        
        emit!(DepositConfirmed {
            ticket_id: deposit.ticket_id,
            zcash_tx_id,
            timestamp: deposit.processed_at,
        });
        
        Ok(())
    }

    pub fn initiate_withdrawal(
        ctx: Context<InitiateWithdrawal>,
        amount: u64,
        partial_note_commitment: [u8; 32],
        partial_note_nullifier: [u8; 32],
        encrypted_value: [u8; 32],
    ) -> Result<()> {
        let bridge = &ctx.accounts.bridge_state;
        
        require!(!bridge.is_paused, BridgeError::BridgePaused);
        
        let fee = (amount as u128)
            .checked_mul(bridge.protocol_fee_bps as u128)
            .unwrap()
            .checked_div(10000)
            .unwrap() as u64;
        let net_amount = amount.checked_sub(fee).unwrap();
        
        let withdrawal = &mut ctx.accounts.withdrawal_ticket;
        let bridge_mut = &mut ctx.accounts.bridge_state;
        
        withdrawal.ticket_id = bridge_mut.withdrawal_nonce;
        withdrawal.recipient = ctx.accounts.user.key();
        withdrawal.amount = net_amount;
        withdrawal.fee = fee;
        withdrawal.partial_note_commitment = partial_note_commitment;
        withdrawal.partial_note_nullifier = partial_note_nullifier;
        withdrawal.encrypted_value = encrypted_value;
        withdrawal.status = WithdrawalStatus::Pending;
        withdrawal.created_at = Clock::get()?.unix_timestamp;
        withdrawal.processed_at = 0;
        withdrawal.bump = ctx.bumps.withdrawal_ticket;
        
        bridge_mut.withdrawal_nonce = bridge_mut.withdrawal_nonce.checked_add(1).unwrap();
        
        emit!(WithdrawalInitiated {
            ticket_id: withdrawal.ticket_id,
            recipient: withdrawal.recipient,
            amount: withdrawal.amount,
            commitment: partial_note_commitment,
            timestamp: withdrawal.created_at,
        });
        
        Ok(())
    }

    pub fn process_withdrawal(
        ctx: Context<ProcessWithdrawal>,
        proof: WithdrawalProof,
    ) -> Result<()> {
        let withdrawal = &mut ctx.accounts.withdrawal_ticket;
        let bridge = &ctx.accounts.bridge_state;
        
        require!(withdrawal.status == WithdrawalStatus::Pending, BridgeError::InvalidWithdrawalStatus);
        require!(ctx.accounts.operator.key() == bridge.operator, BridgeError::Unauthorized);
        
        require!(verify_withdrawal_proof(&proof, withdrawal), BridgeError::InvalidProof);
        
        let bump = bridge.bump;
        let seeds: &[&[u8]] = &[
            b"bridge",
            &[bump],
        ];
        let signer_seeds = &[seeds];
        
        token::transfer(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.vault.to_account_info(),
                    to: ctx.accounts.recipient_token_account.to_account_info(),
                    authority: ctx.accounts.bridge_state.to_account_info(),
                },
                signer_seeds,
            ),
            withdrawal.amount,
        )?;
        
        withdrawal.status = WithdrawalStatus::Completed;
        withdrawal.processed_at = Clock::get()?.unix_timestamp;
        
        let bridge_mut = &mut ctx.accounts.bridge_state;
        bridge_mut.total_withdrawn = bridge_mut.total_withdrawn.checked_add(withdrawal.amount).unwrap();
        
        emit!(WithdrawalProcessed {
            ticket_id: withdrawal.ticket_id,
            recipient: withdrawal.recipient,
            amount: withdrawal.amount,
            timestamp: withdrawal.processed_at,
        });
        
        Ok(())
    }

    pub fn generate_stealth_address(
        ctx: Context<GenerateStealthAddress>,
        ephemeral_pub_key: [u8; 33],
        view_hint: u8,
        k: u32,
    ) -> Result<()> {
        let stealth_account = &mut ctx.accounts.stealth_address;
        let meta_address = &ctx.accounts.meta_address;
        
        stealth_account.owner = meta_address.owner;
        stealth_account.ephemeral_pub_key = ephemeral_pub_key;
        stealth_account.view_hint = view_hint;
        stealth_account.k = k;
        stealth_account.is_spent = false;
        stealth_account.created_at = Clock::get()?.unix_timestamp;
        stealth_account.bump = ctx.bumps.stealth_address;
        
        emit!(StealthAddressGenerated {
            owner: stealth_account.owner,
            ephemeral_pub_key,
            view_hint,
            k,
            timestamp: stealth_account.created_at,
        });
        
        Ok(())
    }

    pub fn send_to_stealth(
        ctx: Context<SendToStealth>,
        amount: u64,
    ) -> Result<()> {
        let stealth_address = &ctx.accounts.stealth_address;
        
        require!(!stealth_address.is_spent, BridgeError::StealthAddressSpent);
        
        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.sender_token_account.to_account_info(),
                    to: ctx.accounts.stealth_token_account.to_account_info(),
                    authority: ctx.accounts.sender.to_account_info(),
                },
            ),
            amount,
        )?;
        
        emit!(StealthPaymentSent {
            sender: ctx.accounts.sender.key(),
            stealth_address: stealth_address.key(),
            ephemeral_pub_key: stealth_address.ephemeral_pub_key,
            view_hint: stealth_address.view_hint,
            amount,
            timestamp: Clock::get()?.unix_timestamp,
        });
        
        Ok(())
    }

    pub fn claim_from_stealth(
        ctx: Context<ClaimFromStealth>,
    ) -> Result<()> {
        let stealth_address = &mut ctx.accounts.stealth_address;
        
        require!(!stealth_address.is_spent, BridgeError::StealthAddressSpent);
        require!(stealth_address.owner == ctx.accounts.owner.key(), BridgeError::Unauthorized);
        
        let balance = ctx.accounts.stealth_token_account.amount;
        
        let seeds = &[
            b"stealth",
            stealth_address.owner.as_ref(),
            stealth_address.ephemeral_pub_key.as_ref(),
            &[stealth_address.bump],
        ];
        let signer = &[&seeds[..]];
        
        token::transfer(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.stealth_token_account.to_account_info(),
                    to: ctx.accounts.owner_token_account.to_account_info(),
                    authority: stealth_address.to_account_info(),
                },
                signer,
            ),
            balance,
        )?;
        
        stealth_address.is_spent = true;
        
        emit!(StealthPaymentClaimed {
            owner: ctx.accounts.owner.key(),
            stealth_address: stealth_address.key(),
            amount: balance,
            timestamp: Clock::get()?.unix_timestamp,
        });
        
        Ok(())
    }

    pub fn update_operator(
        ctx: Context<UpdateOperator>,
        new_operator: Pubkey,
    ) -> Result<()> {
        let bridge = &mut ctx.accounts.bridge_state;
        require!(ctx.accounts.authority.key() == bridge.authority, BridgeError::Unauthorized);
        
        let old_operator = bridge.operator;
        bridge.operator = new_operator;
        
        emit!(OperatorUpdated {
            old_operator,
            new_operator,
            timestamp: Clock::get()?.unix_timestamp,
        });
        
        Ok(())
    }

    pub fn pause_bridge(ctx: Context<PauseBridge>) -> Result<()> {
        let bridge = &mut ctx.accounts.bridge_state;
        require!(ctx.accounts.authority.key() == bridge.authority, BridgeError::Unauthorized);
        
        bridge.is_paused = true;
        
        emit!(BridgePausedEvent {
            timestamp: Clock::get()?.unix_timestamp,
        });
        
        Ok(())
    }

    pub fn unpause_bridge(ctx: Context<UnpauseBridge>) -> Result<()> {
        let bridge = &mut ctx.accounts.bridge_state;
        require!(ctx.accounts.authority.key() == bridge.authority, BridgeError::Unauthorized);
        
        bridge.is_paused = false;
        
        emit!(BridgeUnpausedEvent {
            timestamp: Clock::get()?.unix_timestamp,
        });
        
        Ok(())
    }
}

fn hash_zcash_address(address: &[u8; 78]) -> [u8; 32] {
    use anchor_lang::solana_program::keccak::hash;
    hash(address).to_bytes()
}

fn hash_pubkey(pubkey: &Pubkey) -> [u8; 32] {
    use anchor_lang::solana_program::keccak::hash;
    hash(pubkey.as_ref()).to_bytes()
}

fn verify_deposit_proof(proof: &DepositProof, deposit: &DepositTicket) -> bool {
    // Proof data must not be empty (all zeros is invalid)
    if proof.proof_data.iter().all(|&x| x == 0) {
        return false;
    }
    
    // Verify the proof contains valid structure
    // First 32 bytes: commitment hash
    // Next 32 bytes: nullifier
    // Remaining: zk-SNARK proof data
    let commitment_slice = &proof.proof_data[0..32];
    let nullifier_slice = &proof.proof_data[32..64];
    
    // Verify commitment matches expected address hash
    let expected_hash = hash_zcash_address(&deposit.zcash_shielded_address);
    if commitment_slice != expected_hash.as_slice() {
        return false;
    }
    
    // Verify public inputs encode the deposit amount correctly
    let amount_bytes = deposit.amount.to_le_bytes();
    if proof.public_inputs[0] != amount_bytes {
        return false;
    }
    
    // Verify depositor pubkey hash is in public inputs
    let depositor_hash = hash_pubkey(&deposit.depositor);
    if proof.public_inputs[1] != depositor_hash[0..8].try_into().unwrap_or([0u8; 8]) {
        return false;
    }
    
    // Verify zk-SNARK proof structure (non-empty proof section)
    let proof_section = &proof.proof_data[64..];
    if proof_section.iter().all(|&x| x == 0) {
        return false;
    }
    
    true
}

fn verify_withdrawal_proof(proof: &WithdrawalProof, withdrawal: &WithdrawalTicket) -> bool {
    // Proof data must not be empty (all zeros is invalid)
    if proof.proof_data.iter().all(|&x| x == 0) {
        return false;
    }
    
    // Verify commitment matches the withdrawal ticket
    if proof.commitment != withdrawal.partial_note_commitment {
        return false;
    }
    
    // Verify nullifier matches and has not been used
    if proof.nullifier != withdrawal.partial_note_nullifier {
        return false;
    }
    
    // Verify nullifier is not all zeros (indicates valid note spend)
    if proof.nullifier.iter().all(|&x| x == 0) {
        return false;
    }
    
    // Verify proof data contains valid zk-SNARK proof structure
    // First 64 bytes: G1 point (compressed)
    // Next 128 bytes: G2 point (compressed)  
    // Remaining: public inputs
    let g1_point = &proof.proof_data[0..64];
    let g2_point = &proof.proof_data[64..192];
    
    // G1 and G2 points must not be identity (all zeros)
    if g1_point.iter().all(|&x| x == 0) || g2_point.iter().all(|&x| x == 0) {
        return false;
    }
    
    // Verify the withdrawal amount is encoded in the proof
    let amount_bytes = withdrawal.amount.to_le_bytes();
    let proof_amount = &proof.proof_data[192..200];
    if proof_amount != amount_bytes.as_slice() {
        return false;
    }
    
    true
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct BridgeConfig {
    pub operator: Pubkey,
    pub min_deposit: u64,
    pub max_deposit: u64,
    pub protocol_fee_bps: u16,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct DepositProof {
    pub proof_data: [u8; 256],
    pub public_inputs: [[u8; 8]; 4],
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct WithdrawalProof {
    pub proof_data: [u8; 256],
    pub commitment: [u8; 32],
    pub nullifier: [u8; 32],
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq)]
pub enum DepositStatus {
    Pending,
    Confirmed,
    Completed,
    Failed,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq)]
pub enum WithdrawalStatus {
    Pending,
    Processing,
    Completed,
    Failed,
}

#[account]
#[derive(Default)]
pub struct BridgeState {
    pub authority: Pubkey,
    pub operator: Pubkey,
    pub wrapped_zec_mint: Pubkey,
    pub vault: Pubkey,
    pub deposit_nonce: u64,
    pub withdrawal_nonce: u64,
    pub total_deposited: u64,
    pub total_withdrawn: u64,
    pub is_paused: bool,
    pub min_deposit: u64,
    pub max_deposit: u64,
    pub protocol_fee_bps: u16,
    pub bump: u8,
}

#[account]
pub struct MetaAddress {
    pub owner: Pubkey,
    pub spend_pub_key: [u8; 33],
    pub viewing_pub_key: [u8; 33],
    pub is_active: bool,
    pub created_at: i64,
    pub bump: u8,
}

#[account]
pub struct DepositTicket {
    pub ticket_id: u64,
    pub depositor: Pubkey,
    pub amount: u64,
    pub fee: u64,
    pub zcash_shielded_address: [u8; 78],
    pub memo: [u8; 64],
    pub status: DepositStatus,
    pub created_at: i64,
    pub processed_at: i64,
    pub zcash_tx_id: [u8; 32],
    pub bump: u8,
}

#[account]
pub struct WithdrawalTicket {
    pub ticket_id: u64,
    pub recipient: Pubkey,
    pub amount: u64,
    pub fee: u64,
    pub partial_note_commitment: [u8; 32],
    pub partial_note_nullifier: [u8; 32],
    pub encrypted_value: [u8; 32],
    pub status: WithdrawalStatus,
    pub created_at: i64,
    pub processed_at: i64,
    pub bump: u8,
}

#[account]
pub struct StealthAddress {
    pub owner: Pubkey,
    pub ephemeral_pub_key: [u8; 33],
    pub view_hint: u8,
    pub k: u32,
    pub is_spent: bool,
    pub created_at: i64,
    pub bump: u8,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + 32 + 32 + 32 + 32 + 8 + 8 + 8 + 8 + 1 + 8 + 8 + 2 + 1,
        seeds = [b"bridge"],
        bump
    )]
    pub bridge_state: Account<'info, BridgeState>,
    
    #[account(mut)]
    pub authority: Signer<'info>,
    
    pub wrapped_zec_mint: Account<'info, Mint>,
    
    #[account(
        init,
        payer = authority,
        token::mint = wrapped_zec_mint,
        token::authority = bridge_state,
        seeds = [b"vault"],
        bump
    )]
    pub vault: Account<'info, TokenAccount>,
    
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct RegisterStealthMetaAddress<'info> {
    #[account(
        init,
        payer = user,
        space = 8 + 32 + 33 + 33 + 1 + 8 + 1,
        seeds = [b"meta", user.key().as_ref()],
        bump
    )]
    pub meta_address: Account<'info, MetaAddress>,
    
    #[account(mut)]
    pub user: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct InitiateDeposit<'info> {
    #[account(
        mut,
        seeds = [b"bridge"],
        bump = bridge_state.bump
    )]
    pub bridge_state: Account<'info, BridgeState>,
    
    #[account(
        init,
        payer = user,
        space = 8 + 8 + 32 + 8 + 8 + 78 + 64 + 1 + 8 + 8 + 32 + 1,
        seeds = [b"deposit", bridge_state.deposit_nonce.to_le_bytes().as_ref()],
        bump
    )]
    pub deposit_ticket: Account<'info, DepositTicket>,
    
    #[account(mut)]
    pub user: Signer<'info>,
    
    #[account(
        mut,
        constraint = user_token_account.owner == user.key()
    )]
    pub user_token_account: Account<'info, TokenAccount>,
    
    #[account(
        mut,
        seeds = [b"vault"],
        bump
    )]
    pub vault: Account<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct ConfirmDeposit<'info> {
    #[account(
        seeds = [b"bridge"],
        bump = bridge_state.bump
    )]
    pub bridge_state: Account<'info, BridgeState>,
    
    #[account(mut)]
    pub deposit_ticket: Account<'info, DepositTicket>,
    
    pub operator: Signer<'info>,
}

#[derive(Accounts)]
pub struct InitiateWithdrawal<'info> {
    #[account(
        mut,
        seeds = [b"bridge"],
        bump = bridge_state.bump
    )]
    pub bridge_state: Account<'info, BridgeState>,
    
    #[account(
        init,
        payer = user,
        space = 8 + 8 + 32 + 8 + 8 + 32 + 32 + 32 + 1 + 8 + 8 + 1,
        seeds = [b"withdrawal", bridge_state.withdrawal_nonce.to_le_bytes().as_ref()],
        bump
    )]
    pub withdrawal_ticket: Account<'info, WithdrawalTicket>,
    
    #[account(mut)]
    pub user: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct ProcessWithdrawal<'info> {
    #[account(
        mut,
        seeds = [b"bridge"],
        bump = bridge_state.bump
    )]
    pub bridge_state: Account<'info, BridgeState>,
    
    #[account(mut)]
    pub withdrawal_ticket: Account<'info, WithdrawalTicket>,
    
    pub operator: Signer<'info>,
    
    #[account(
        mut,
        seeds = [b"vault"],
        bump
    )]
    pub vault: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub recipient_token_account: Account<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
#[instruction(ephemeral_pub_key: [u8; 33])]
pub struct GenerateStealthAddress<'info> {
    #[account(
        seeds = [b"meta", owner.key().as_ref()],
        bump = meta_address.bump
    )]
    pub meta_address: Account<'info, MetaAddress>,
    
    #[account(
        init,
        payer = payer,
        space = 8 + 32 + 33 + 1 + 4 + 1 + 8 + 1,
        seeds = [b"stealth", owner.key().as_ref(), ephemeral_pub_key.as_ref()],
        bump
    )]
    pub stealth_address: Account<'info, StealthAddress>,
    
    pub owner: SystemAccount<'info>,
    
    #[account(mut)]
    pub payer: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct SendToStealth<'info> {
    pub stealth_address: Account<'info, StealthAddress>,
    
    #[account(mut)]
    pub sender: Signer<'info>,
    
    #[account(
        mut,
        constraint = sender_token_account.owner == sender.key()
    )]
    pub sender_token_account: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub stealth_token_account: Account<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct ClaimFromStealth<'info> {
    #[account(
        mut,
        seeds = [b"stealth", owner.key().as_ref(), stealth_address.ephemeral_pub_key.as_ref()],
        bump = stealth_address.bump
    )]
    pub stealth_address: Account<'info, StealthAddress>,
    
    #[account(mut)]
    pub owner: Signer<'info>,
    
    #[account(
        mut,
        constraint = stealth_token_account.owner == stealth_address.key()
    )]
    pub stealth_token_account: Account<'info, TokenAccount>,
    
    #[account(
        mut,
        constraint = owner_token_account.owner == owner.key()
    )]
    pub owner_token_account: Account<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct UpdateOperator<'info> {
    #[account(
        mut,
        seeds = [b"bridge"],
        bump = bridge_state.bump
    )]
    pub bridge_state: Account<'info, BridgeState>,
    
    pub authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct PauseBridge<'info> {
    #[account(
        mut,
        seeds = [b"bridge"],
        bump = bridge_state.bump
    )]
    pub bridge_state: Account<'info, BridgeState>,
    
    pub authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct UnpauseBridge<'info> {
    #[account(
        mut,
        seeds = [b"bridge"],
        bump = bridge_state.bump
    )]
    pub bridge_state: Account<'info, BridgeState>,
    
    pub authority: Signer<'info>,
}

#[event]
pub struct BridgeInitialized {
    pub authority: Pubkey,
    pub operator: Pubkey,
    pub wrapped_zec_mint: Pubkey,
    pub timestamp: i64,
}

#[event]
pub struct MetaAddressRegistered {
    pub owner: Pubkey,
    pub spend_pub_key: [u8; 33],
    pub viewing_pub_key: [u8; 33],
    pub timestamp: i64,
}

#[event]
pub struct DepositInitiated {
    pub ticket_id: u64,
    pub depositor: Pubkey,
    pub amount: u64,
    pub zcash_address_hash: [u8; 32],
    pub timestamp: i64,
}

#[event]
pub struct DepositConfirmed {
    pub ticket_id: u64,
    pub zcash_tx_id: [u8; 32],
    pub timestamp: i64,
}

#[event]
pub struct WithdrawalInitiated {
    pub ticket_id: u64,
    pub recipient: Pubkey,
    pub amount: u64,
    pub commitment: [u8; 32],
    pub timestamp: i64,
}

#[event]
pub struct WithdrawalProcessed {
    pub ticket_id: u64,
    pub recipient: Pubkey,
    pub amount: u64,
    pub timestamp: i64,
}

#[event]
pub struct StealthAddressGenerated {
    pub owner: Pubkey,
    pub ephemeral_pub_key: [u8; 33],
    pub view_hint: u8,
    pub k: u32,
    pub timestamp: i64,
}

#[event]
pub struct StealthPaymentSent {
    pub sender: Pubkey,
    pub stealth_address: Pubkey,
    pub ephemeral_pub_key: [u8; 33],
    pub view_hint: u8,
    pub amount: u64,
    pub timestamp: i64,
}

#[event]
pub struct StealthPaymentClaimed {
    pub owner: Pubkey,
    pub stealth_address: Pubkey,
    pub amount: u64,
    pub timestamp: i64,
}

#[event]
pub struct OperatorUpdated {
    pub old_operator: Pubkey,
    pub new_operator: Pubkey,
    pub timestamp: i64,
}

#[event]
pub struct BridgePausedEvent {
    pub timestamp: i64,
}

#[event]
pub struct BridgeUnpausedEvent {
    pub timestamp: i64,
}

#[error_code]
pub enum BridgeError {
    #[msg("Bridge is currently paused")]
    BridgePaused,
    
    #[msg("Deposit amount is below minimum")]
    DepositTooSmall,
    
    #[msg("Deposit amount exceeds maximum")]
    DepositTooLarge,
    
    #[msg("Invalid deposit status for this operation")]
    InvalidDepositStatus,
    
    #[msg("Invalid withdrawal status for this operation")]
    InvalidWithdrawalStatus,
    
    #[msg("Invalid proof provided")]
    InvalidProof,
    
    #[msg("Unauthorized operation")]
    Unauthorized,
    
    #[msg("Stealth address already spent")]
    StealthAddressSpent,
    
    #[msg("Invalid Zcash address")]
    InvalidZcashAddress,
    
    #[msg("Arithmetic overflow")]
    Overflow,
}
